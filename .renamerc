# rename-files - rename files in a current directory based on a regex pattern and replacement
function rename-files() {
  local pattern
  local replacement
  local doit

  if [[ "$2" == "" ]]; then
    echo "Usage: $0 <regex_pattern> <replacement> [--doit]"
    return 1
  fi

  pattern="$1"
  replacement="$2"
  doit="$3"

  if [[ "$doit" == "--doit" ]]; then
    rename "s/$pattern/$replacement/" -- *
  else
    rename -n "s/$pattern/$replacement/" -- *
    echo "Dry run only. Use --doit as the 4th argument to actually rename files."
  fi
}

# rename-files-using-sed - rename files in a current directory based on a regex pattern and replacement
function rename-files-using-sed() {
  local pattern
  local replacement
  local doit
  local newName

  if [[ "$2" == "" ]]; then
    echo "Usage: $0 <regex_pattern> <replacement> [--doit]"
    echo ""
    printf ' Examples:\n'
    printf '  rename-files-using-sed "\\(.*\\) (1).mp3" "\\1_uk.mp3"\n'
    printf '  rename-files-using-sed "^\\([^_]*\\).mp3$" "\\1_us.mp3"\n'
    return 1
  fi

  pattern="$1"
  replacement="$2"
  doit="$3"

  for file in *; do
    newName=$(echo "$file" | sed "s/$pattern/$replacement/")
    if [[ "$file" != "$newName" ]]; then
      if [[ "$doit" == "--doit" ]]; then
        mv "$file" "$newName"
      else
        echo "Would rename '$file' to '$newName'"
      fi
    fi
  done

  if [[ "$doit" != "--doit" ]]; then
    echo "Dry run only. Use --doit as the 3rd argument to actually rename files."
  fi
}
